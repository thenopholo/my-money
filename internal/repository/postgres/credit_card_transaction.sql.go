// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: credit_card_transaction.sql

package postgres

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const assignTransactionToInvoice = `-- name: AssignTransactionToInvoice :exec
UPDATE credit_card_transactions
SET "invoice_id" = $2
WHERE "id" = $1
`

type AssignTransactionToInvoiceParams struct {
	ID        uuid.UUID   `json:"id"`
	InvoiceID pgtype.UUID `json:"invoice_id"`
}

func (q *Queries) AssignTransactionToInvoice(ctx context.Context, arg AssignTransactionToInvoiceParams) error {
	_, err := q.db.Exec(ctx, assignTransactionToInvoice, arg.ID, arg.InvoiceID)
	return err
}

const createCreditCardTransaction = `-- name: CreateCreditCardTransaction :one
INSERT INTO credit_card_transactions (
    "card_id", "category_id", "invoice_id", "amount", "description",
    "installments", "current_installment", "installment_value", "transaction_date"
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, card_id, category_id, invoice_id, amount, description, installments, current_installment, installment_value, transaction_date, created_at
`

type CreateCreditCardTransactionParams struct {
	CardID             uuid.UUID      `json:"card_id"`
	CategoryID         uuid.UUID      `json:"category_id"`
	InvoiceID          pgtype.UUID    `json:"invoice_id"`
	Amount             pgtype.Numeric `json:"amount"`
	Description        string         `json:"description"`
	Installments       int32          `json:"installments"`
	CurrentInstallment int32          `json:"current_installment"`
	InstallmentValue   pgtype.Numeric `json:"installment_value"`
	TransactionDate    pgtype.Date    `json:"transaction_date"`
}

func (q *Queries) CreateCreditCardTransaction(ctx context.Context, arg CreateCreditCardTransactionParams) (CreditCardTransaction, error) {
	row := q.db.QueryRow(ctx, createCreditCardTransaction,
		arg.CardID,
		arg.CategoryID,
		arg.InvoiceID,
		arg.Amount,
		arg.Description,
		arg.Installments,
		arg.CurrentInstallment,
		arg.InstallmentValue,
		arg.TransactionDate,
	)
	var i CreditCardTransaction
	err := row.Scan(
		&i.ID,
		&i.CardID,
		&i.CategoryID,
		&i.InvoiceID,
		&i.Amount,
		&i.Description,
		&i.Installments,
		&i.CurrentInstallment,
		&i.InstallmentValue,
		&i.TransactionDate,
		&i.CreatedAt,
	)
	return i, err
}

const deleteCreditCardTransaction = `-- name: DeleteCreditCardTransaction :exec
DELETE FROM credit_card_transactions WHERE "id" = $1
`

func (q *Queries) DeleteCreditCardTransaction(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteCreditCardTransaction, id)
	return err
}

const getCreditCardTransactionByID = `-- name: GetCreditCardTransactionByID :one
SELECT id, card_id, category_id, invoice_id, amount, description, installments, current_installment, installment_value, transaction_date, created_at FROM credit_card_transactions WHERE "id" = $1
`

func (q *Queries) GetCreditCardTransactionByID(ctx context.Context, id uuid.UUID) (CreditCardTransaction, error) {
	row := q.db.QueryRow(ctx, getCreditCardTransactionByID, id)
	var i CreditCardTransaction
	err := row.Scan(
		&i.ID,
		&i.CardID,
		&i.CategoryID,
		&i.InvoiceID,
		&i.Amount,
		&i.Description,
		&i.Installments,
		&i.CurrentInstallment,
		&i.InstallmentValue,
		&i.TransactionDate,
		&i.CreatedAt,
	)
	return i, err
}

const getCreditCardTransactionsByCardID = `-- name: GetCreditCardTransactionsByCardID :many
SELECT id, card_id, category_id, invoice_id, amount, description, installments, current_installment, installment_value, transaction_date, created_at FROM credit_card_transactions WHERE "card_id" = $1
`

func (q *Queries) GetCreditCardTransactionsByCardID(ctx context.Context, cardID uuid.UUID) ([]CreditCardTransaction, error) {
	rows, err := q.db.Query(ctx, getCreditCardTransactionsByCardID, cardID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CreditCardTransaction
	for rows.Next() {
		var i CreditCardTransaction
		if err := rows.Scan(
			&i.ID,
			&i.CardID,
			&i.CategoryID,
			&i.InvoiceID,
			&i.Amount,
			&i.Description,
			&i.Installments,
			&i.CurrentInstallment,
			&i.InstallmentValue,
			&i.TransactionDate,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCreditCardTransactionsByCategoryID = `-- name: GetCreditCardTransactionsByCategoryID :many
SELECT id, card_id, category_id, invoice_id, amount, description, installments, current_installment, installment_value, transaction_date, created_at FROM credit_card_transactions WHERE "category_id" = $1
`

func (q *Queries) GetCreditCardTransactionsByCategoryID(ctx context.Context, categoryID uuid.UUID) ([]CreditCardTransaction, error) {
	rows, err := q.db.Query(ctx, getCreditCardTransactionsByCategoryID, categoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CreditCardTransaction
	for rows.Next() {
		var i CreditCardTransaction
		if err := rows.Scan(
			&i.ID,
			&i.CardID,
			&i.CategoryID,
			&i.InvoiceID,
			&i.Amount,
			&i.Description,
			&i.Installments,
			&i.CurrentInstallment,
			&i.InstallmentValue,
			&i.TransactionDate,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCreditCardTransactionsByInvoiceID = `-- name: GetCreditCardTransactionsByInvoiceID :many
SELECT id, card_id, category_id, invoice_id, amount, description, installments, current_installment, installment_value, transaction_date, created_at FROM credit_card_transactions WHERE "invoice_id" = $1
`

func (q *Queries) GetCreditCardTransactionsByInvoiceID(ctx context.Context, invoiceID pgtype.UUID) ([]CreditCardTransaction, error) {
	rows, err := q.db.Query(ctx, getCreditCardTransactionsByInvoiceID, invoiceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CreditCardTransaction
	for rows.Next() {
		var i CreditCardTransaction
		if err := rows.Scan(
			&i.ID,
			&i.CardID,
			&i.CategoryID,
			&i.InvoiceID,
			&i.Amount,
			&i.Description,
			&i.Installments,
			&i.CurrentInstallment,
			&i.InstallmentValue,
			&i.TransactionDate,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingCreditCardTransactions = `-- name: GetPendingCreditCardTransactions :many
SELECT id, card_id, category_id, invoice_id, amount, description, installments, current_installment, installment_value, transaction_date, created_at FROM credit_card_transactions
WHERE "card_id" = $1 AND "invoice_id" IS NULL
`

func (q *Queries) GetPendingCreditCardTransactions(ctx context.Context, cardID uuid.UUID) ([]CreditCardTransaction, error) {
	rows, err := q.db.Query(ctx, getPendingCreditCardTransactions, cardID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CreditCardTransaction
	for rows.Next() {
		var i CreditCardTransaction
		if err := rows.Scan(
			&i.ID,
			&i.CardID,
			&i.CategoryID,
			&i.InvoiceID,
			&i.Amount,
			&i.Description,
			&i.Installments,
			&i.CurrentInstallment,
			&i.InstallmentValue,
			&i.TransactionDate,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCreditCardTransaction = `-- name: UpdateCreditCardTransaction :one
UPDATE credit_card_transactions
SET "amount" = $2, "description" = $3, "installments" = $4,
    "current_installment" = $5, "installment_value" = $6, "transaction_date" = $7
WHERE "id" = $1
RETURNING id, card_id, category_id, invoice_id, amount, description, installments, current_installment, installment_value, transaction_date, created_at
`

type UpdateCreditCardTransactionParams struct {
	ID                 uuid.UUID      `json:"id"`
	Amount             pgtype.Numeric `json:"amount"`
	Description        string         `json:"description"`
	Installments       int32          `json:"installments"`
	CurrentInstallment int32          `json:"current_installment"`
	InstallmentValue   pgtype.Numeric `json:"installment_value"`
	TransactionDate    pgtype.Date    `json:"transaction_date"`
}

func (q *Queries) UpdateCreditCardTransaction(ctx context.Context, arg UpdateCreditCardTransactionParams) (CreditCardTransaction, error) {
	row := q.db.QueryRow(ctx, updateCreditCardTransaction,
		arg.ID,
		arg.Amount,
		arg.Description,
		arg.Installments,
		arg.CurrentInstallment,
		arg.InstallmentValue,
		arg.TransactionDate,
	)
	var i CreditCardTransaction
	err := row.Scan(
		&i.ID,
		&i.CardID,
		&i.CategoryID,
		&i.InvoiceID,
		&i.Amount,
		&i.Description,
		&i.Installments,
		&i.CurrentInstallment,
		&i.InstallmentValue,
		&i.TransactionDate,
		&i.CreatedAt,
	)
	return i, err
}
